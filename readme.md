# PSO 알고리즘 구현 및 새로운 시도

pso 알고리즘을 사용하여 새로운 학습 방법을 찾는중 입니다
병렬처리로 사용하는 논문을 찾아보았지만 이보다 더 좋은 방법이 있을 것 같아서 찾아보고 있습니다 - A Distribute Deep Learning System Using PSO Algorithm.pdf

기본 pso 알고리즘의 수식은 다음과 같습니다

> $$V_{id(t+1)} = W_{V_id(t)} + c_1 * r_1 (p_{id(t)} - x_{id(t)}) + c_2 * r_2(p_{gd(t)} - x_{id(t)})$$

다음 속도을 구하는 수식입니다

> $$x_{id(t+1)} = x_{id(t)} + V_{id(t+1)}$$

다음 위치를 구하는 수식입니다

> $$p_{id(t+1)} = \begin{cases} x_{id(t+1)} & \text{if } f(x_{id(t+1)}) < f(p_{id(t)}) \\ p_{id(t)} & \text{otherwise} \end{cases}$$

### 위치를 가장 최적값으로 변경(덮어쓰기)하면 안되는 이유

위치를 가장 최적값으로 변경하면 지역 최적값에서 벗어나지 못합니다. 따라서 전역 최적값을 찾을 수 없습니다.

# 현재 진행 상황

## 1. PSO 알고리즘 구현

```plain text
pso.py  # PSO 알고리즘 구현
pso_tf.py # tensorflow 모델을 이용가능한 PSO 알고리즘 구현

xor.ipynb # xor 문제를 pso 알고리즘으로 풀이
mnist.ipynb # mnist 문제를 pso 알고리즘으로 풀이
```

## 2. PSO 알고리즘을 이용한 최적화 문제 풀이

pso 알고리즘을 이용하여 오차역전파 함수를 최적화 하는 방법을 찾는 중입니다

### 임시 아이디어

1. 오차역전파 함수를 1~5회 실행하여 오차를 구합니다
2. 오차가 가장 적은 다른 노드(particle) 가중치로 유도합니다.

   2-1. 만약 오차가 가장 작은 다른 노드가 현재 노드보다 오차가 크다면, 현재 노드의 가중치를 유지합니다. - 현재의 가중치를 최적값으로 업로드합니다

   2-2. 지역 최적값을 찾았다면, 전역 최적값을 찾을 때까지 1~2 과정을 반복합니다

3. 전역 최적값이 특정 임계치에서 변화율이 적다면 학습을 종료합니다

### 개인적인 생각

> 머신러닝 분류 방식에 존재하는 random forest 방식을 이용하여, 오차역전파 함수를 최적화 하는 방법이 있을것 같습니다
>
> > pso 와 random forest 방식이 매우 유사하다고 생각하여 학습할 때 뿐만 아니라 예측 할 때도 이러한 방식으로 사용할 수 있을 것 같습니다
